---
title: "Analysis on Air Pollution in US Citites"
author: "Hieu Hoang"
date: "2025-05-29"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

# Load libraries
library(HSAUR2)
library(ggplot2)
library(dplyr)
library(tools)
library(MASS)  # For LDA/QDA
library(klaR)  # For Box's M test
library(psych) # For pairs.panels
library(corrplot) # For correlation plots
library(heplots) # For Box's M test
library(MASS) 
```

```{r}
# Load the data
air_data <- USairpollution
air_data
```

```{r}
# Basic data exploration
str(air_data)
summary(air_data)
```

```{r}
# Create a correlation matrix
cor_matrix <- cor(air_data)
cor_matrix

# Visualize correlation matrix
corrplot(cor_matrix, method = "color", type = "upper", 
         tl.col = "black", tl.srt = 45, addCoef.col = "black")
```

```{r}
# Create pairs plot to visualize relationships between variables
pairs.panels(air_data, 
             method = "pearson", 
             hist.col = "#00AFBB",
             density = TRUE, 
             ellipses = TRUE)
```

```{r}
# Create boxplots for each variable
par(mfrow = c(2, 4))
for(i in 1:ncol(air_data)) {
  boxplot(air_data[,i], main = names(air_data)[i], col = "lightblue")
}
par(mfrow = c(1, 1))
```

```{r}
# Create scatterplots of SO2 against each predictor
par(mfrow = c(2, 3))
for(i in 2:ncol(air_data)) {
  plot(air_data[,i], air_data$SO2, 
       xlab = names(air_data)[i], 
       ylab = "SO2", 
       main = paste("SO2 vs", names(air_data)[i]),
       pch = 19, col = "blue")
  abline(lm(air_data$SO2 ~ air_data[,i]), col = "red")
}
par(mfrow = c(1, 1))
```

```{r}
# Create a heatmap of the data
# First, scale the data
scaled_data <- scale(air_data)
heatmap(as.matrix(scaled_data), 
        col = colorRampPalette(c("blue", "white", "red"))(100),
        main = "Heatmap of Air Pollution Data",
        xlab = "Variables", 
        ylab = "Cities")
```

```{r}
# Create a barplot of SO2 levels by city
# Sort cities by SO2 level
sorted_data <- air_data[order(air_data$SO2, decreasing = TRUE),]
barplot(sorted_data$SO2, 
        names.arg = rownames(sorted_data),
        las = 2, 
        cex.names = 0.7,
        col = "steelblue",
        main = "SO2 Levels by City",
        ylab = "SO2 (micrograms per cubic meter)")
```

```{r}
# Prepare for multivariate analysis by categorizing cities by pollution level
# Create a new variable for pollution level based on SO2 quartiles
air_data$pollution_level <- cut(air_data$SO2, 
                               breaks = quantile(air_data$SO2, probs = c(0, 0.25, 0.5, 0.75, 1)),
                               labels = c("Very Low", "Low", "Medium", "High"),
                               include.lowest = TRUE)

# Check the distribution of pollution levels
table(air_data$pollution_level)

# Visualize the distribution of pollution levels
barplot(table(air_data$pollution_level), 
        col = c("green", "lightgreen", "orange", "red"),
        main = "Distribution of Pollution Levels",
        xlab = "Pollution Level",
        ylab = "Number of Cities")
```

```{r}
pca_res <- prcomp(air_data[, c("SO2", "temp", "popul")], scale. = TRUE)
summary(pca_res)
```

```{r}
plot(pca_res, type = "l")
```

```{r}
X <- air_data[, c("SO2", "temp", "popul")]
Y <- air_data$pollution_level
data_all <- data.frame(Y = Y, X)

data_all$Y <- factor(data_all$Y)

set.seed(100)
train_idx <- sample(1:nrow(data_all), 0.8 * nrow(data_all))  # 80% train
train_data <- data_all[train_idx, ]
test_data <- data_all[-train_idx, ]

# === QDA ===
qda_model <- qda(Y ~ ., data = train_data)
qda_pred <- predict(qda_model, newdata = test_data)
qda_conf_matrix <- table(Predicted = qda_pred$class, Actual = test_data$Y)
qda_accuracy <- sum(diag(qda_conf_matrix)) / sum(qda_conf_matrix)
print("QDA Confusion Matrix:")
print(qda_conf_matrix)
print(paste("QDA Accuracy:", round(qda_accuracy * 100, 2), "%"))

# === LDA ===
lda_model <- lda(Y ~ ., data = train_data)
lda_pred <- predict(lda_model, newdata = test_data)
lda_conf_matrix <- table(Predicted = lda_pred$class, Actual = test_data$Y)
lda_accuracy <- sum(diag(lda_conf_matrix)) / sum(lda_conf_matrix)
print("LDA Confusion Matrix:")
print(lda_conf_matrix)
print(paste("LDA Accuracy:", round(lda_accuracy * 100, 2), "%"))

```

```{r}
# Prepare the predictor matrix (drop SO2 and pollution_level)
predictors <- air_data[, c("temp", "wind", "precip", "predays", "manu", "popul")]

# Confirm no missing values
sum(is.na(predictors))   # should return 0

# Scale predictors to mean=0, sd=1
predictors_scaled <- scale(predictors)

# Run PCA on scaled predictors
pca_all <- prcomp(predictors_scaled, center = TRUE, scale. = FALSE)

# Examine summary (eigenvalues, proportion of variance, cumulative)
summary(pca_all)

```


```{r}
# Inspect loadings (rotation matrix)
round(pca_all$rotation, 3)
```

```{r}
# Add PC scores back to original data, color by pollution_level
scores <- as.data.frame(pca_all$x)
scores$city            <- rownames(air_data)
scores$pollution_level <- air_data$pollution_level

ggplot(scores, aes(x = PC1, y = PC2, color = pollution_level)) +
  geom_point(size = 2) +
  geom_text(aes(label = city), hjust = 1.05, vjust = 0.5, size = 2.5) +
  scale_color_manual(values = c(
    "Very Low" = "green4",
    "Low"      = "chartreuse3",
    "Medium"   = "gold",
    "High"     = "red"
  )) +
  labs(
    title = "PC1 vs PC2: Cities Colored by Pollution Level",
    x     = "Principal Component 1",
    y     = "Principal Component 2"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom", legend.title = element_blank())
```





```{r}

# Compute eigenvalues (variance explained by each PC)
eigenvalues <- pca_all$sdev^2

# Compute proportion of variance explained by each PC
prop_var <- eigenvalues / sum(eigenvalues)

# Compute cumulative contribution ratio (Cr)
Cr <- cumsum(prop_var)

# Print Cr for each PC
Cr

# Find the smallest k such that Cr[k] â‰¥ 0.80 (i.e., 80%)
k80 <- which(Cr >= 0.80)[1]
cat("Keep", k80, "components to cover at least 80% of variance\n")


```



```{r}
# Plot the Cr curve with a horizontal line at 0.80
plot(
  x = seq_along(Cr),
  y = Cr,
  type = "b",
  pch = 19,
  col = "steelblue",
  xlab = "Principal Component",
  ylab = "Cumulative Contribution (Cr)",
  main = "Cumulative Contribution Ratio"
)
abline(h = 0.80, col = "red", lty = 2)
text(k80, Cr[k80] + 0.03, paste0("k = ", k80), col = "red")
```

```{r}
# Scree Plot
# Plot eigenvalues versus component index
plot(
  x = seq_along(eigenvalues),
  y = eigenvalues,
  type = "b",
  pch = 19,
  col = "darkgreen",
  xlab = "Principal Component",
  ylab = "Eigenvalue",
  main = "Scree Plot"
)
# 2. Draw a horizontal line at the average eigenvalue (Kaiser criterion)
abline(h = mean(eigenvalues), col = "orange", lty = 2)
legend(
  "topright",
  legend = c("Eigenvalues", "Average = 1"),
  col    = c("darkgreen", "orange"),
  pch    = c(19, NA),
  lty    = c(NA, 2),
  bty    = "n"
)
```
```{r}
# Prepare the matrix of scaled predictors (same as PCA input)
mat <- as.matrix(predictors_scaled)
rownames(mat) <- rownames(air_data)  # city names
colnames(mat) <- colnames(predictors) # temp, wind, precip, predays, manu, popul

# Draw the heatmap
heatmap(
  mat,
  Colv = NA,             # do not reorder columns
  Rowv = NA,             # do not reorder rows
  scale = "none",        # already scaled
  col   = colorRampPalette(c("navy", "white", "firebrick"))(100),
  margins = c(6, 8),     # room for labels
  main    = "Heatmap of Scaled Predictors",
  xlab    = "Variables",
  ylab    = "Cities"
)
```

